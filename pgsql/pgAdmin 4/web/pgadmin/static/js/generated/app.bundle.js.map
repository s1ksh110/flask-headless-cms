{"version":3,"file":"app.bundle.js","mappings":";;;AAsHA","sources":["webpack:///./pgadmin/tools/erd/static/js/erd_tool/links/OneToManyLink.jsx"],"sourcesContent":["/////////////////////////////////////////////////////////////\n//\n// pgAdmin 4 - PostgreSQL Tools\n//\n// Copyright (C) 2013 - 2025, The pgAdmin Development Team\n// This software is released under the PostgreSQL Licence\n//\n//////////////////////////////////////////////////////////////\n\nimport React, { forwardRef, useContext } from 'react';\nimport {\n  RightAngleLinkModel,\n  RightAngleLinkWidget,\n  DefaultLinkFactory,\n  PortModelAlignment,\n  LinkWidget,\n  PointModel,\n} from '@projectstorm/react-diagrams';\nimport {Point} from '@projectstorm/geometry';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport { styled } from '@mui/material/styles';\nimport { ERDCanvasSettings } from '../components/ERDTool';\nimport { keyframes } from '@emotion/react';\n\nexport const POINTER_SIZE = 30;\n\nexport const OneToManyModel = {\n  local_table_uid: undefined,\n  local_column_attnum: undefined,\n  referenced_table_uid: undefined,\n  referenced_column_attnum: undefined,\n};\n\nexport class OneToManyLinkModel extends RightAngleLinkModel {\n  constructor({data, ...options}) {\n    super({\n      type: 'onetomany',\n      width: 1,\n      class: 'link-onetomany',\n      locked: true,\n      ...options,\n    });\n\n    this._data = {\n      ...data,\n    };\n    this._linkPointType = {\n      sourceType: 'one',\n      targetType: 'many'\n    };\n  }\n\n  getData() {\n    return this._data;\n  }\n\n  setData(data) {\n    this._data = data;\n  }\n\n  serializeData(nodesDict) {\n    let data = this.getData();\n    let target = nodesDict[data['local_table_uid']].getData();\n    let source = nodesDict[data['referenced_table_uid']].getData();\n    return {\n      'schema': target.schema,\n      'table': target.name,\n      'remote_schema': source.schema,\n      'remote_table': source.name,\n      'columns': [{\n        'local_column': _.find(target.columns, (col)=>data.local_column_attnum == col.attnum).name,\n        'referenced': _.find(source.columns, (col)=>data.referenced_column_attnum == col.attnum).name,\n      }],\n    };\n  }\n\n  serialize() {\n    return {\n      ...super.serialize(),\n      data: this.getData(),\n    };\n  }\n\n  setPointType(nodesDict) {\n    let data = this.getData();\n    let target = nodesDict[data['local_table_uid']].getData();\n    let colName = _.find(target.columns, (col)=>data.local_column_attnum == col.attnum).name;\n    let {pkCols=[], ukCols=[]} = nodesDict[data['local_table_uid']].getConstraintCols();\n    let targetType = pkCols.includes(colName) || ukCols.includes(colName) ? 'one' : 'many';\n    this._linkPointType = {\n      ...this._linkPointType,\n      targetType,\n    };\n  }\n\n  getPointType() {\n    return this._linkPointType;\n  }\n\n  setFirstAndLastPathsDirection() {\n    let points = this.getPoints();\n    if (points.length > 2){\n      super.setFirstAndLastPathsDirection();\n    } else {\n      let dx = Math.abs(points[1].getX() - points[0].getX());\n      let dy = Math.abs(points[1].getY() - points[0].getY());\n      this._firstPathXdirection = dx > dy;\n      this._lastPathXdirection = dx > dy;\n    }\n  }\n}\n\nconst svgLinkSelected =   keyframes`\n  from { stroke-dashoffset: 24;}\n  to { stroke-dashoffset: 0; }\n`;\n\nconst StyledG = styled('g')((\n  {\n    theme\n  }\n) => ({\n\n  '& .OneToMany-svgLink': {\n    stroke: theme.palette.text.primary,\n    fontSize: '0.8em',\n  },\n  '& .OneToMany-svgLinkCircle': {\n    fill: theme.palette.text.primary,\n  },\n\n  '& .OneToMany-svgLinkSelected': {\n    strokeDasharray: '10, 2',\n    animation: `${svgLinkSelected} 1s linear infinite`\n  },\n  '& .OneToMany-svgLinkPath': {\n    pointerEvents: 'all',\n    cursor: 'move',\n  }\n}));\n\n\nfunction ChenNotation({rotation, type}) {\n\n  const textX = Math.sign(rotation) > 0 ? -14 : 8;\n  const textY = -5;\n  return (\n    <>\n      <text className='OneToMany-svgLink' x={textX} y={textY} transform={'rotate(' + -rotation + ')' }>\n        {type == 'one' ? '1' : 'N'}\n      </text>\n      <line className='OneToMany-svgLink' x1=\"0\" y1=\"0\" x2=\"0\" y2=\"30\"></line>\n    </>\n  );\n}\nChenNotation.propTypes = {\n  rotation: PropTypes.number,\n  type: PropTypes.string,\n};\n\nfunction NotationForType({itype, width, rotation}) {\n  const settings = useContext(ERDCanvasSettings);\n\n  if(settings.cardinality_notation == 'chen') {\n    return <ChenNotation rotation={rotation} type={itype} />;\n  }\n  if(itype == 'many') {\n    return (\n      <>\n        <circle className={['OneToMany-svgLink','OneToMany-svgLinkCircle'].join(' ')} cx=\"0\" cy=\"16\" r={width*2.5} />\n        <polyline className='OneToMany-svgLink' points=\"-8,0 0,15 0,0 0,30 0,15 8,0\" fill=\"none\" />\n      </>\n    );\n  } else if (itype == 'one') {\n    return (\n      <polyline className='OneToMany-svgLink' points=\"-8,15 0,15 0,0 0,30 0,15 8,15\" fill=\"none\" strokeWidth={width} />\n    );\n  }\n}\n\nNotationForType.propTypes = {\n  itype: PropTypes.oneOf(['many', 'one']).isRequired,\n  rotation: PropTypes.number.isRequired,\n  width: PropTypes.number,\n};\n\n\nexport class OneToManyLinkWidget extends RightAngleLinkWidget {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.setPointType();\n    this.updateLinkListener = this.props.link.registerListener({\n      updateLink: ()=>{\n        this.setPointType();\n        this.setState({});\n      }\n    });\n  }\n\n  componentWillUnmount() {\n    this.props.link.deregisterListener(this.updateLinkListener);\n  }\n\n  setPointType() {\n    this.props.link.setPointType(this.props.diagramEngine.getModel().getNodesDict());\n  }\n\n  endPointTranslation(alignment) {\n    let degree = 0;\n    let tx = 0, ty = 0;\n    switch(alignment) {\n    case PortModelAlignment.BOTTOM:\n      ty = -POINTER_SIZE;\n      break;\n    case PortModelAlignment.LEFT:\n      degree = 90;\n      tx = POINTER_SIZE;\n      break;\n    case PortModelAlignment.TOP:\n      degree = 180;\n      ty = POINTER_SIZE;\n      break;\n    case PortModelAlignment.RIGHT:\n      degree = -90;\n      tx = -POINTER_SIZE;\n      break;\n    }\n    return [degree, tx, ty];\n  }\n\n  addCustomWidgetPoint(type, endpoint, point) {\n    const [rotation, tx, ty] = this.endPointTranslation(endpoint.options.alignment);\n    if(!point) {\n      point = this.props.link.point(\n        endpoint.getX()-tx, endpoint.getY()-ty, {'one': 1, 'many': 2}[type]\n      );\n    } else {\n      point.setPosition(endpoint.getX()-tx, endpoint.getY()-ty);\n    }\n\n    return {\n      type: type,\n      point: point,\n      rotation: rotation,\n      tx: tx,\n      ty: ty,\n    };\n  }\n\n  generateCustomEndWidget({type, point, rotation, tx, ty}) {\n    return (\n      <g key={point.getID()} transform={'translate(' + point.getPosition().x + ', ' + point.getPosition().y + ')'}>\n        <g transform={'translate('+tx+','+ty+')'}>\n          <g transform={'rotate(' + rotation + ')' }>\n            <NotationForType itype={type} width={this.props.width} rotation={rotation} />\n          </g>\n        </g>\n      </g>\n    );\n  }\n\n  draggingEvent(event, index) {\n    let points = this.props.link.getPoints();\n    // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n    // moving with y direction\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  handleMove = function(event) {\n    this.props.link.getTargetPort();\n    this.draggingEvent(event, this.dragging_index);\n    this.props.link.fireEvent({}, 'positionChanged');\n  }.bind(this);\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = [];\n    let {sourceType, targetType} = this.props.link.getPointType();\n\n    let onePoint = this.addCustomWidgetPoint(sourceType, this.props.link.getSourcePort(), points[0]);\n    let manyPoint = this.addCustomWidgetPoint(targetType, this.props.link.getTargetPort(), points[points.length-1]);\n\n    if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else if (this.props.link.getLastPathXdirection()) {\n          points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n        } else {\n          points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n        }\n      }\n    }\n\n    // If there is existing link which has two points add one\n    // and the link is horizontal\n    if (points.length === 2 && !this.state.canDrag && onePoint.point.getX() != manyPoint.point.getX()) {\n      this.props.link.addPoint(\n        new PointModel({\n          link: this.props.link,\n          position: new Point(onePoint.point.getX(), manyPoint.point.getY()),\n        })\n      );\n    }\n\n    paths.push(this.generateCustomEndWidget(onePoint));\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(\n        this.generateLink(\n          LinkWidget.generateLinePath(points[j], points[j + 1]),\n          {\n            'data-linkid': this.props.link.getID(),\n            'data-point': j,\n            onMouseDown: (event) => {\n              if (event.button === 0) {\n                this.setState({ canDrag: true });\n                this.dragging_index = j;\n                // Register mouse move event to track mouse position\n                // On mouse up these events are unregistered check \"this.handleUp\"\n                window.addEventListener('mousemove', this.handleMove);\n                window.addEventListener('mouseup', this.handleUp);\n              }\n            },\n            onMouseEnter: () => {\n              this.setState({ selected: true });\n              this.props.link.lastHoverIndexOfPath = j;\n            },\n          },\n          j\n        )\n      );\n    }\n    paths.push(this.generateCustomEndWidget(manyPoint));\n\n    return <StyledG data-default-link-test={this.props.link.getOptions().testName}>{paths}</StyledG>;\n  }\n}\n\nconst LinkSegment = forwardRef(({selected, path, ...props}, ref)=>{\n\n  return (\n    <path\n      ref={ref}\n      className={['OneToMany-svgLink','OneToMany-svgLinkPath', (selected ? 'OneToMany-svgLinkSelected' : '')].join(' ')}\n      selected={selected}\n      d={path}\n      {...props}\n    >\n    </path>\n  );\n});\nLinkSegment.displayName = 'LinkSegment';\nLinkSegment.propTypes = {\n  model: PropTypes.object,\n  selected: PropTypes.bool,\n  path: PropTypes.any,\n};\n\n\nexport class OneToManyLinkFactory extends DefaultLinkFactory {\n  constructor() {\n    super('onetomany');\n  }\n\n  generateModel(event) {\n    return new OneToManyLinkModel(event.initialConfig);\n  }\n\n  generateReactWidget(event) {\n    return <OneToManyLinkWidget width={1} smooth={true} link={event.model} diagramEngine={this.engine} factory={this} />;\n  }\n\n  generateLinkSegment(model, selected, path) {\n    return <LinkSegment model={model} selected={selected} path={path} />;\n  }\n}\n"],"names":[],"sourceRoot":""}